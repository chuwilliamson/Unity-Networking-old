#pragma warning disable 0168
#pragma warning disable 0219
#pragma warning disable 0414

using UnityEngine;

using UnityEngine.Networking;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine.Events;
using UnityEngine.UI;


/*
SyncEvents allow networked actions to be propagated to other scripts attached to the object. In the example above, the Other class registers for the TakeDamage event on the DamageClass. When the event happens on the DamageClass on the server, the TakeDamage() method will be invoked on the Other class on the client object. This allows modular network aware systems to be created, that can be extended by new scripts that respond to the events generated by them.
*/

public class GameManager : NetworkBehaviour
{
    public delegate void EventPlayerChange();

    [SyncEvent]
    public static event EventPlayerChange EventOnPlayerChange;  

    static public GameManager singleton;
    static public List<PlayerManager> m_Players = new List<PlayerManager>();

    private WaitForSeconds m_Wait;

	[Header("UI")]
    [SerializeField]
    private GameObject m_UI;
    private UIServer m_UIServer;

	[Header("GameState")]
    [SyncVar]
    public bool hasStarted = false;

	[SyncVar]
	public bool quit = false;
    
	[Header("Player")]
	[SerializeField]
    public Player activePlayer;

	[SerializeField]
	private List<Player> Players = new List<Player>();    

	[SyncVar]
	private int m_activePlayerIndex;

	[Header("Cards")]
	//assign in inspector
//	public GameObject TreasureStack;
//	public GameObject DiscardStack;

//    private TreasureStack m_TreasureStack;
//    
//    private DiscardStack m_DiscardStack;

    private PlayerManager m_activePlayerManager;

    public PlayerManager activePlayerManager
    {
        get
        {
            return m_activePlayerManager;
        }
        set
        {
            m_activePlayerManager = value;
            activePlayer = m_activePlayerManager.Player;
            m_activePlayerManager.SetReady();            
        }
    }

    #region Setup
    public static void AddPlayer(GameObject player, int playerNum, Color c, string name, int localID)
    {
		
        PlayerManager pm = new PlayerManager();
        pm.Setup(player, playerNum, c, name, localID);
        m_Players.Add(pm);
    }


    public void RemovePlayer(GameObject p)
    {
        PlayerManager toRemove = null;
        foreach (var tmp in m_Players)
        {
            if (tmp.Instance == p)
            {
                toRemove = tmp;
                break;
            }
        }

        if (toRemove != null)
            m_Players.Remove(toRemove);
    }
    #endregion Setup

    
    void Awake()
    {
        singleton = this;

        m_UIServer = m_UI.GetComponent<UIServer>();
		GetComponent<TreasureStack>().Setup();
		GetComponent<DiscardStack>().Setup();
        m_Wait = new WaitForSeconds(1); 
    }

    [ServerCallback]
    void Start()
    {
        foreach (PlayerManager pm in m_Players)
            Players.Add(pm.Player);

        
       
        m_activePlayerIndex = 0;
        activePlayerManager = m_Players[m_activePlayerIndex];
        EventOnPlayerChange += RpcPlayerChange;
        StartCoroutine(GameLoop());
    }

    IEnumerator GameLoop()
    {        
       
        //wait to be sure that all are ready to start
		yield return m_Wait;
        yield return StartCoroutine(GameStart());
        yield return StartCoroutine(PlayerTurn());
        yield return StartCoroutine(GameRunning());
    }

    [ClientRpc]
    public void RpcPlayerChange()
    {
        Debug.Log("PlayerChange Event!");
        if (EventOnPlayerChange != null)
            EventOnPlayerChange();
    }   

 

    IEnumerator GameStart()
    {
        print("GameStart()");

        RpcGameStart();
        hasStarted = true;
        yield return null;
    }

    [ClientRpc]
    private void RpcGameStart()
    {
        EnableControls();
		GetComponent<TreasureStack>().SpawnCards();
    }

    IEnumerator PlayerTurn()
    {

    
        activePlayerManager.SetReady();
        
        while (activePlayerManager.IsTakingTurn)
        {
            yield return null;
        }

        m_activePlayerIndex += 1;
        if (m_activePlayerIndex >= m_Players.Count)
            m_activePlayerIndex = 0;

        activePlayerManager = m_Players[m_activePlayerIndex];


        yield return null;
        yield return StartCoroutine(PlayerTurn());
    }
    IEnumerator GameRunning()
    {
        Debug.Log("Game Running...");
        while (m_Players.Count > 1)
        {
            yield return new WaitForSeconds(1);
            yield return null;
        }
        print("Shutting down server");
        Application.Quit();
    }


    private void EnableControls()
    {
        for (int i = 0; i < m_Players.Count; ++i)
        {
            m_Players[i].EnableControl();
        }
    }

    private void DisableControls()
    {
        for (int i = 0; i < m_Players.Count; ++i)
        {
            m_Players[i].DisableControl();
        }
    }

    void SetCouchCams()
    {

        Rect Left = new Rect(0, 0, 1, .5f);
        Rect Right = new Rect(0, 0.5f, 1, .5f);
        m_Players[0].PlayerCamera.rect = Left;
        m_Players[1].PlayerCamera.rect = Right;
    }

}


